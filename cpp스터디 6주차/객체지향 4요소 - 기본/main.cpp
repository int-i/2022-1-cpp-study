#include <iostream>
using std::cin;
using std::cout;
using std::endl;

// 객체 지향 프로그래밍의 4요소
// 추상화, 캡슐화, 상속성, 다형성
// 이 4가지 요소(사람에 따라 추상화는 빼고 3요소라 하는경우도 있음)는 객체 지향 프로그래밍을
// 지원하는 프로그래밍 언어라면 전부 제공하는 요소들이다.
// 
// 1. 추상화(Abstraction)
// 사실상 클래스 그 자체가 추상화를 구현한 것이라 볼 수 있다.
// 클래스란 현실의 개념을 컴퓨터가 이해할 수 있게끔 추상화 한 것을 의미하기 때문!
// 따라서 추상화를 제외하고 객체 지향 프로그래밍의 3요소라 부르는 경우도 많다.
// ex)
class 동물 {
public:
	동물(int 다리개수, bool 아가미유무, bool 털유무) {
		this->다리개수 = 다리개수;
		this->아가미유무 = 아가미유무;
		this->털유무 = 털유무;
	}
	// 가상 함수
	virtual void display() { cout << "동물 입니다." << endl; };
	int get_다리개수() { return 다리개수; }
private:
	int 다리개수;
	bool 아가미유무;
	bool 털유무;
};
// 위 처럼 동물이라는 개념을 컴퓨터가 이해할 수 있게끔 추상화 할 수 있다.
// 
// 2. 캡슐화(Encapsulation)
// 변수와 함수를 하나의 단위로 묶는 것을 의미한다.
// 이를 번들링이라 부르는데 추상화와 마찬가지로 클래스 그 자체의 성질이라 볼 수 있다.
// 
// 클래스는 여러 변수들을 멤버 변수(필드)라는 이름으로 클래스에 담고
// 여러 함수들을 멤버 함수(메서드)라는 이름으로 클래스에 담는다.
// 
// 그리고 이 클래스를 통해 객체를 생성하면, 이 객체는 해당 클래스의 필드와 메서드들을 모두 갖고 있기 때문에
// 해당 객체에 .연산자 또는 ->연산자(포인터 객체일 때만)를 통해
// 해당 객체를 구성하는 클래스의 필드 또는 메서드에 쉽게 접근 할 수 있다.
// 
// ex)
// 동물 강아지{ 4, false, true };
// 강아지.get_다리개수();
// 
// 위처럼 여러 데이터를 한데 묶어놓는 것 그것을 캡슐화라 부른다.
// 이와 더불어서 정보은닉이라는 개념도 있는데,
// 
// 정보 은닉은 캡슐화로부터 파생된 보조 개념으로,
// 프로그램의 세부 구현을 외부로 드러나지 않도록 감추는 것을 의미한다.
// 
// 대부분의 객체지향 언어에선 접근 지정자가 이를 위해서 제공 되는데,
// 
// public: 클래스의 외부에서 사용 가능하도록 노출시키는 것
// protected: 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것
// private: 클래스의 내부에서만 사용되며 외부로 노출되지 않음
// 
// python같은 경우에는 이건 지원하지 않는다.
// 
// 3. 상속성(Inheritance)
// 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것이다.
// (부모 클래스의 필드와 메서드를 모두 물려받는 것)
// 기능(함수)의 일부분을 변경해야 할 경우 자식 클래스에서
// 상속받은 그 기능만을 수정해서 다시 정의(오버라이딩)하게 되는데,
// 이러한 작업을 '오버라이딩(overriding)'이라고 한다.
// 
// 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.
// 더 자세히 설명하는건 너무 길어지므로 추후 각 요소 상세 설명시간때 추가로 설명 예정
// ex)
class 포유류 : public 동물 {
public:
	// 멤버 이니셜라이저 리스트
	// 익명 동물 객체를 만들고 있다.
	// 이를 통해 동물 클래스의 생성자를 호출
	포유류() : 동물{ 4, false, true } { }
	virtual void display() { cout << "포유류 입니다." << endl; }; // 오버라이딩
};

// 포유류 고양이{ };
// 고양이.get_다리개수();
// 4 반환
// 
// 상속받은 자식 클래스의 생성자는 멤버 초기화 리스트를 통해 부모 클래스의 생성자를 반드시 호출해야한다.
// is-a 관계가 바로 이런 관계이다. 포유류 is a 동물
// 
// 4. 다형성(Polymorphism)
// 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것을 의미한다.
// 다형성은 여러가지 의미가 있는데, 보통 객체지향에서 말하는 다형성은 서브타입 다형성
// 기초 클래스 또는 어떠한 인터페이스를 구현하는 상위 클래스를 생성하고,
// 해당 클래스를 상속받는 다수의 하위 클래스들을 만들어,
// 상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조하게 하는 것
// 
// 이것도 마찬가지로 더 자세히 설명하는건 너무 길어지므로 추후 각 요소 상세 설명때 추가로 설명 예정
//
// ex)
class 파충류 : public 동물 {
	파충류() : 동물{ 4, false, true } { }

	// 함수 오버라이딩
	// 가상 함수: 부모클래스의 가상함수는 자식클래스에서 오버라이딩이 가능함
	virtual void display() { cout << "파충류 입니다." << endl; };
};
// 동물* 동물포인터 = new 파충류{ };
// 동물포인터->display();
// 파충류 입니다 출력



// 오버라이딩
// 오버라이딩 상속받은 클래스의 메서드를 변경하는 것

// 오버로딩
// 상속과는 관계없이 이름이 같은 다른 함수가 있을 때
// 매개변수를 달리하여 다른 기능을 하게 하는 것

// 둘의 차이점
// 오버로딩은 무조건 매개변수가 달라야 하고
// 오버라이딩은 매개변수가 동일해도 괜찮다.

int main() {

	return 0;
}
